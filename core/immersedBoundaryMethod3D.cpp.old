#ifndef IMMERSEDBOUNDARYMETHOD_3D_HH
#define IMMERSEDBOUNDARYMETHOD_3D_HH


#include "hemocell.h"
#include "immersedBoundaryMethod3D.h"
#include "surfaceParticle3D.h"
#include <cmath>

#ifndef PI__
#define PI__
const double pi = 4.*atan(1.);
#endif  // PI__

namespace plb {

/// Decide if a Lagrangian point is contained in 3D box, boundaries exclusive
inline bool contained_sane(Array<int,3> const& x, Box3D const& box) {
    return x[0]>=box.x0 && x[0]<=box.x1 &&
           x[1]>=box.y0 && x[1]<=box.y1 &&
           x[2]>=box.z0 && x[2]<=box.z1;
}
    
    
inline double phi2 (double x) {
    x = fabs(x);
    x = 1.0 - x;
    return max(x,0.0);
}

template<typename T>
inline T phi3 (T x) {
    x = fabs(x);
    if (x <= 0.5) {
        return 1.0/3.0 * (1 + sqrt(1 - 3*x*x));
    } else if (x<= 1.5) {
        return 1.0/6.0 * (5 - 3*x - sqrt(-2 + 6*x - 3*x*x) );
    } else {
        return 0;
    }
}

template<typename T>
inline T phi4 (T x) {
    x = fabs(x);
    if (x <= 1.0) {
        return 0.125 * (3 - 2*x + sqrt(1 + 4*x - 4*x*x));
    } else if (x<= 2.0) {
        return 0.125 * (5 - 2*x - sqrt(-7 + 12*x - 4*x*x));
    } else {
        return 0;
    }
}

template<typename T>
inline T phi4c (T x) {
    x = fabs(x);
    if (x<=2)
        return 0.25*(1 + cos(pi*x*0.5));
    else
        return 0.0;
}

template<typename T, template<typename U> class Descriptor>
void interpolationCoefficients (
        BlockLattice3D<T,Descriptor> const& block, Array<T,3> const& position,
        std::vector<Dot3D>& cellPos, std::vector<T>& weights) {
    /*
     * ibmKernel == 1, Phi1
     * ibmKernel == 2, Phi2 ! Default
     * ibmKernel == 3, Phi3
     * ibmKernel == 4, Phi4
     * ibmKernel == 5, Phi4c
     */
    #if HEMOCELL_KERNEL == 1
    	interpolationCoefficientsPhi1(block, position, cellPos, weights);
    #elif HEMOCELL_KERNEL == 2
        interpolationCoefficientsPhi2(block, position, cellPos, weights);
    #elif HEMOCELL_KERNEL == 3
        interpolationCoefficientsPhi3(block, position, cellPos, weights);
    #elif HEMOCELL_KERNEL == 4
        interpolationCoefficientsPhi4(block, position, cellPos, weights);
    #elif HEMOCELL_KERNEL == 5
        interpolationCoefficientsPhi4c(block, position, cellPos, weights);
    #else // Default
        interpolationCoefficientsPhi2(block, position, cellPos, weights);
    #endif
}

template<typename T, template<typename U> class Descriptor>
inline void interpolationCoefficientsPhi1 (
        BlockLattice3D<T,Descriptor> const& block, Array<T,3> const& position,
        std::vector<Dot3D>& cellPos, std::vector<T>& weights )
{
    cellPos.clear();
    weights.clear();

    T totWeight = 0;
    
    // Fixed kernel size.
    plint x0=-1, x1=2;
    
    Box3D boundingBox(block.getBoundingBox());
    for (int dx = x0; dx < x1; ++dx) {
        for (int dy = x0; dy < x1; ++dy) {
            for (int dz = x0; dz < x1; ++dz) {
                Dot3D cellPosition(Dot3D( (plint) position[0] + dx, (plint) position[1] + dy, (plint) position[2] + dz));
                Dot3D cellPositionInDomain = cellPosition - block.getLocation(); // Convert cell position to local coordinates.
                if (contained(cellPositionInDomain,boundingBox)) {
                    T phi[3];
                    phi[0] = (position[0] - 0.5 - (T)cellPosition.x);
                    phi[1] = (position[1] - 0.5 - (T)cellPosition.y);
                    phi[2] = (position[2] - 0.5 - (T)cellPosition.z);

                    if(not block.get(cellPositionInDomain.x, cellPositionInDomain.y, cellPositionInDomain.z).getDynamics().isBoundary()) {
                    	T dist = sqrt(phi[0] * phi[0] + phi[1] * phi[1] + phi[2] * phi[2]);
                    	//T dist = phi[0] * phi[0] + phi[1] * phi[1] + phi[2] * phi[2];
                        if(dist < 0.01) dist = 0.01; // Dont let the 27 point kernel turn into a completely single point one
                        dist = 1.0 / dist;
                    	
                        totWeight += dist;
                        weights.push_back(dist);
                        cellPos.push_back(cellPositionInDomain);
                    }
                }
            }
        }
    }

    for(pluint j = 0; j < weights.size(); j++)
    	weights[j] /= totWeight;
}

inline void interpolationCoefficientsPhi2 (
        BlockLattice3D<double,DESCRIPTOR> const& block, SurfaceParticle3D * particle)
{
    //Clean current
    particle->kernelWeights.clear();
    particle->kernelLocations.clear();
    
    // Fixed kernel size
    const plint x0=-1, x1=2; //const for nice loop unrolling

    //Coordinates are relative
    const Dot3D tmpDot = block.getLocation(); 
    const Array<plint,3> relLoc = {tmpDot.x, tmpDot.y, tmpDot.z};

    //Get position, relative
    const Array<double,3> position_tmp = particle->getPosition();
    const Array<double,3> position = {position_tmp[0] -relLoc[0], position_tmp[1]-relLoc[1],position_tmp[2]-relLoc[2]};

    //Get our reference node (0,0)
    const Array<plint,3> center(position[0] + 0.5, position[1] + 0.5, position[2] + 0.5); 
    
    //Boundingbox of lattice
    const Box3D boundingBox = block.getBoundingBox();
    
    //Prealloc is better than JItalloc
    Array<plint,3> posInBlock;
    double phi[3];
    double weight;
    
    for (int dx = x0; dx < x1; ++dx) {
        for (int dy = x0; dy < x1; ++dy) {
            for (int dz = x0; dz < x1; ++dz) {
                posInBlock = {center[0] + dx, center[1] + dy, center[2] + dz};
                if (contained_sane(posInBlock,boundingBox)) {
                    phi[0] = (position[0] - posInBlock[0]); //Get absolute distance
                    phi[1] = (position[1] - posInBlock[1]);
                    phi[2] = (position[2] - posInBlock[2]);
                    weight = phi2(phi[0]) * phi2(phi[1]) * phi2(phi[2]);

                    if (weight>0) {
                        particle->kernelWeights.push_back(weight);
                        particle->kernelLocations.push_back(block.getPointer(posInBlock[0],posInBlock[1],posInBlock[2]));
                    }
                }
            }
        }
    }
}


template<typename T, template<typename U> class Descriptor>
void interpolationCoefficientsPhi3 (
        BlockLattice3D<T,Descriptor> const& block, Array<T,3> const& position,
        std::vector<Dot3D>& cellPos, std::vector<T>& weights )
{
    cellPos.clear();
    weights.clear();

    plint x0=-2, x1=2+1;
    Box3D boundingBox(block.getBoundingBox());
    for (int dx = x0; dx < x1; ++dx) {
        for (int dy = x0; dy < x1; ++dy) {
            for (int dz = x0; dz < x1; ++dz) {
                Dot3D cellPosition(Dot3D( (plint) position[0] + dx, (plint) position[1] + dy, (plint) position[2] + dz));
                Dot3D cellPositionInDomain = cellPosition - block.getLocation(); // Convert cell position to local coordinates.
                if (contained(cellPositionInDomain,boundingBox)) {
                    T phi[3];
                    phi[0] = (position[0] - 0.5 - (T)cellPosition.x);
                    phi[1] = (position[1] - 0.5 - (T)cellPosition.y);
                    phi[2] = (position[2] - 0.5 - (T)cellPosition.z);
                    T weight = phi3(phi[0]) * phi3(phi[1]) * phi3(phi[2]);
                    if (weight>0) {
                        weights.push_back(weight);
                        cellPos.push_back(cellPositionInDomain);
                    }
                }
            }
        }
    }
}


void interpolationCoefficientsPhi4 (
        BlockLattice3D<double,DESCRIPTOR> const& block, Array<double,3> const& position,
        std::vector<Dot3D>& cellPos, std::vector<double>& weights)
{
    cellPos.clear();
    weights.clear();

    plint x0=-2, x1=2+1;
    Box3D boundingBox(block.getBoundingBox());
    for (int dx = x0; dx < x1; ++dx) {
        for (int dy = x0; dy < x1; ++dy) {
            for (int dz = x0; dz < x1; ++dz) {
                Dot3D cellPosition(Dot3D( (plint) position[0] + dx, (plint) position[1] + dy, (plint) position[2] + dz));
                Dot3D cellPositionInDomain = cellPosition - block.getLocation(); // Convert cell position to local coordinates.
                if (contained(cellPositionInDomain,boundingBox)) {
                    double phi[3];
                    phi[0] = (position[0] - 0.5 - cellPosition.x);
                    phi[1] = (position[1] - 0.5 - cellPosition.y);
                    phi[2] = (position[2] - 0.5 - cellPosition.z);
                    double weight = phi4(phi[0]) * phi4(phi[1]) * phi4(phi[2]);
                    if (weight>0) {
                        weights.push_back(weight);
                        cellPos.push_back(cellPositionInDomain);
                    }
                }
            }
        }
    }
}

template<typename T, template<typename U> class Descriptor>
void interpolationCoefficientsPhi4c (
        BlockLattice3D<T,Descriptor> const& block, Array<T,3> const& position,
        std::vector<Dot3D>& cellPos, std::vector<T>& weights)
{
    cellPos.clear();
    weights.clear();
 
    plint x0=-2, x1=2+1;
    Box3D boundingBox(block.getBoundingBox());
    for (int dx = x0; dx < x1; ++dx) {
        for (int dy = x0; dy < x1; ++dy) {
            for (int dz = x0; dz < x1; ++dz) {
                Dot3D cellPosition(Dot3D( (plint) position[0] + dx, (plint) position[1] + dy, (plint) position[2] + dz));
                Dot3D cellPositionInDomain = cellPosition - block.getLocation(); // Convert cell position to local coordinates.
                if (contained(cellPositionInDomain,boundingBox)) {
                    T phi[3];
                    phi[0] = (position[0] - 0.5 - (T)cellPosition.x);
                    phi[1] = (position[1] - 0.5 - (T)cellPosition.y);
                    phi[2] = (position[2] - 0.5 - (T)cellPosition.z);
                    T weight = phi4c(phi[0]) * phi4c(phi[1]) * phi4c(phi[2]);
                    if (weight>0) {
                        weights.push_back(weight);
                        cellPos.push_back(cellPositionInDomain);
                    }
                }
            }
        }
    }
}

/*
 * In case one of the interpolating boundary nodes is a boundary,
 * the force is spread to the rest of the nodes
 * */
template<typename T, template<typename U> class Descriptor>
void curateInterpolationCoefficients (BlockLattice3D<T,Descriptor>& fluid,
        std::vector<Dot3D>& cellPos, std::vector<T>& weights) {
    Cell<T,Descriptor>* cell;
    T percentageInBoundaries=1;
    std::vector<T> newWeights = weights;
    std::vector<Dot3D> newCellPos = cellPos;
    weights.clear(); cellPos.clear();
    for (pluint iCell = 0; iCell < newWeights.size() ; ++iCell) {
        Dot3D cellPosition = newCellPos[iCell];
        cell = &fluid.get(cellPosition.x, cellPosition.y, cellPosition.z);
        if (not cell->getDynamics().isBoundary()) {
            percentageInBoundaries -= newWeights[iCell];
            weights.push_back(newWeights[iCell]);
            cellPos.push_back(newCellPos[iCell]);
        }
    }
    plint nRemaining = weights.size();
    if (nRemaining==0) { return ; }
    for (plint iCell = 0; iCell < nRemaining; ++iCell) {
        weights[iCell] += percentageInBoundaries*1.0/nRemaining;
    }
}

}
#endif  // IMMERSEDBOUNDARYMETHOD_3D_HH


//    pcout << "location( " << block.getLocation().x <<
//            block.getLocation().y <<
//            block.getLocation().z <<
//            "), bB =(" << boundingBox.x0 <<
//            ", " << boundingBox.x1 <<
//            "), (" << boundingBox.y0 <<
//            ", " << boundingBox.y1 <<
//            "), " << boundingBox.z0 <<
//            "," << boundingBox.z1 <<
//             "), p.x = (" << position[0] <<
//             ", " << position[1] <<
//             ", " << position[2] << ")" << std::endl;
