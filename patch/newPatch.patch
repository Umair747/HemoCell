diff -ru palabos-v1.5r1/src/offLattice/triangularSurfaceMesh.h palabos/src/offLattice/triangularSurfaceMesh.h
--- palabos-v1.5r1/src/offLattice/triangularSurfaceMesh.h	2015-01-10 19:21:32.000000000 +0100
+++ palabos/src/offLattice/triangularSurfaceMesh.h	2016-11-07 14:52:32.424652763 +0100
@@ -145,6 +145,12 @@
     ///   3.] The third rotation is by an angle psi about the new z-axis.
     void rotate(T phi, T theta, T psi);
 
+    /// Rotate the surface mesh.
+    ///   Alternative method using axial rotations. 
+    ///   The subsequent rotations happen in the following order: around x, around y, around z.
+    ///   Angles are in radians.
+    void rotateXYZ(T alpha, T beta, T gamma);
+
     /// Smooth the surface mesh.
     ///   The triangular surface mesh is smoothed by using a spatial
     ///   averaging algorithm. Interior vertices are treated differently
diff -ru palabos-v1.5r1/src/offLattice/triangularSurfaceMesh.hh palabos/src/offLattice/triangularSurfaceMesh.hh
--- palabos-v1.5r1/src/offLattice/triangularSurfaceMesh.hh	2015-01-13 15:05:09.000000000 +0100
+++ palabos/src/offLattice/triangularSurfaceMesh.hh	2016-11-07 14:52:32.428652873 +0100
@@ -286,6 +286,82 @@
 }
 
 template<typename T>
+void TriangularSurfaceMesh<T>::rotateXYZ(T alpha, T beta, T gamma)
+{
+    static const T pi = std::acos((T) -1.0);
+
+    PLB_ASSERT((theta > T() || util::fpequal(theta, T(), eps0)) &&
+               (theta < pi  || util::fpequal(theta, pi, eps0)));
+
+    // Rotation matrix around x axis (column-first)
+    T a[3][3];
+    a[0][0] =  (T) 1.0;
+    a[0][1] =  (T) 0.0;
+    a[0][2] =  (T) 0.0;
+    a[1][0] =  (T) 0.0;
+    a[1][1] =  std::cos(alpha);
+    a[1][2] =  std::sin(alpha);
+    a[2][0] =  (T) 0.0;
+    a[2][1] = -std::sin(alpha);
+    a[2][2] =  std::cos(alpha);
+
+    // Rotation matrix around y axis (column-first)
+    T b[3][3];
+    b[0][0] =  std::cos(beta);
+    b[0][1] =  (T) 0.0;
+    b[0][2] =  -std::sin(beta);
+    b[1][0] =  (T) 0.0;
+    b[1][1] =  (T) 1.0;
+    b[1][2] =  (T) 0.0;
+    b[2][0] =  std::sin(beta);
+    b[2][1] =  (T) 0.0;
+    b[2][2] =  std::cos(beta);
+
+    // Ry * Rx
+    T c[3][3];
+    for (int i = 0; i < 3; i++) {
+        for (int j = 0; j < 3; j++) {
+            c[i][j] = (T) 0.0;
+            for (int k = 0; k < 3; k++) {
+                c[i][j] += a[k][j]*b[i][k];
+            }
+        }
+    }
+
+    // Rotation matrix around z axis (column-first)
+    b[0][0] =  std::cos(gamma);
+    b[0][1] =  std::sin(gamma);
+    b[0][2] =  (T) 0.0;
+    b[1][0] = -std::sin(gamma);
+    b[1][1] =  std::cos(gamma);
+    b[1][2] =  (T) 0.0;
+    b[2][0] =  (T) 0.0;
+    b[2][1] =  (T) 0.0;
+    b[2][2] =  (T) 1.0;
+
+
+    // Rz * [Ry*Rx]
+    for (int i = 0; i < 3; i++) {
+        for (int j = 0; j < 3; j++) {
+            a[i][j] = (T) 0.0;
+            for (int k = 0; k < 3; k++) {
+                a[i][j] += c[k][j]*b[i][k];
+            }
+        }
+    }
+
+    for (plint iVertex = 0; iVertex < numVertices; iVertex++) {
+        Array<T,3> x = getVertex(iVertex);
+        for (int i = 0; i < 3; i++) {
+            getVertex(iVertex)[i] = (T) 0.0;
+            for (int j = 0; j < 3; j++) {
+                getVertex(iVertex)[i] += a[i][j]*x[j];
+            }
+        }
+    }
+}
+
+template<typename T>
 void TriangularSurfaceMesh<T>::smooth(plint maxiter, T relax, bool isMeasureWeighted)
 {
     PLB_ASSERT(maxiter >= 0);
diff -ru palabos-v1.5r1/src/particles/particleField3D.h palabos/src/particles/particleField3D.h
--- palabos-v1.5r1/src/particles/particleField3D.h	2015-01-10 19:21:32.000000000 +0100
+++ palabos/src/particles/particleField3D.h	2016-11-07 14:52:32.432652984 +0100
@@ -68,6 +68,7 @@
 public:
     /// Helper function: returns if a given particle is situated in the indicated (local) domain.
     bool isContained(Array<T,3> const& particlePos, Box3D box) const;
+    bool isContained(T iX, T iY, T iZ, Box3D box) const;
     void computeGridPosition (
             Array<T,3> const& position,
             plint& iX, plint& iY, plint& iZ ) const;
diff -ru palabos-v1.5r1/src/particles/particleField3D.hh palabos/src/particles/particleField3D.hh
--- palabos-v1.5r1/src/particles/particleField3D.hh	2015-01-10 19:21:32.000000000 +0100
+++ palabos/src/particles/particleField3D.hh	2016-11-07 14:52:32.436653094 +0100
@@ -40,6 +40,20 @@
 
 template<typename T, template<typename U> class Descriptor>
 bool ParticleField3D<T,Descriptor>::isContained (
+        T iX, T iY, T iZ, Box3D box ) const
+{
+    Dot3D const& location = this->getLocation();
+    T x = iX-location.x;
+    T y = iY-location.y;
+    T z = iZ-location.z;
+
+    return (x > (T)box.x0-(T)0.5) && (x <= (T)box.x1+(T)0.5) &&
+           (y > (T)box.y0-(T)0.5) && (y <= (T)box.y1+(T)0.5) &&
+           (z > (T)box.z0-(T)0.5) && (z <= (T)box.z1+(T)0.5);
+}
+
+template<typename T, template<typename U> class Descriptor>
+bool ParticleField3D<T,Descriptor>::isContained (
         Array<T,3> const& particlePos, Box3D box ) const
 {
     Dot3D const& location = this->getLocation();
@@ -661,8 +675,10 @@
 template<typename T, template<typename U> class Descriptor>
 void LightParticleField3D<T,Descriptor>::addParticle(Box3D domain, Particle3D<T,Descriptor>* particle) {
     Box3D finalDomain;
+    Array<T,3> pos; 
+    pos = particle->getPosition();
     if( intersect(domain, this->getBoundingBox(), finalDomain) &&
-        this->isContained(particle->getPosition(), finalDomain) )
+        this->isContained(pos[0],pos[1],pos[2], finalDomain) )
     {
         particles.push_back(particle);
     }
@@ -675,10 +691,12 @@
 void LightParticleField3D<T,Descriptor>::removeParticles(Box3D domain) {
     std::vector<Particle3D<T,Descriptor>*> remainingParticles;
     Box3D finalDomain;
+    Array<T,3> pos; 
     if( intersect(domain, this->getBoundingBox(), finalDomain) )
     {
         for (pluint i=0; i<particles.size(); ++i) {
-            if (this->isContained(particles[i]->getPosition(),finalDomain)) {
+            pos = particles[i]->getPosition();
+            if (this->isContained(pos[0],pos[1],pos[2],finalDomain)) {
                 delete particles[i];
             }
             else {
@@ -695,8 +713,10 @@
     Box3D finalDomain;
     if( intersect(domain, this->getBoundingBox(), finalDomain) )
     {
+        Array<T,3> pos; 
         for (pluint i=0; i<particles.size(); ++i) {
-            if (this->isContained(particles[i]->getPosition(),finalDomain) &&
+            pos = particles[i]->getPosition();
+            if (this->isContained(pos[0],pos[1],pos[2],finalDomain) &&
                 particles[i]->getTag() == tag )
             {
                 delete particles[i];
@@ -715,8 +735,10 @@
 {
     found.clear();
     PLB_ASSERT( contained(domain, this->getBoundingBox()) );
+    Array<T,3> pos; 
     for (pluint i=0; i<particles.size(); ++i) {
-        if (this->isContained(particles[i]->getPosition(),domain)) {
+        pos = particles[i]->getPosition();
+        if (this->isContained(pos[0],pos[1],pos[2],domain)) {
             found.push_back(particles[i]);
         }
     }
@@ -728,8 +750,11 @@
 {
     found.clear();
     PLB_ASSERT( contained(domain, this->getBoundingBox()) );
+    Array<T,3> pos; 
+        
     for (pluint i=0; i<particles.size(); ++i) {
-        if (this->isContained(particles[i]->getPosition(),domain)) {
+        pos = particles[i]->getPosition();
+        if (this->isContained(pos[0],pos[1],pos[2],domain)) {
             found.push_back(particles[i]);
         }
     }
@@ -742,8 +767,10 @@
     Box3D finalDomain;
     if( intersect(domain, this->getBoundingBox(), finalDomain) )
     {
+      Array<T,3> pos;
         for (pluint i=0; i<particles.size(); ++i) {
-            if (this->isContained(particles[i]->getPosition(),finalDomain)) {
+	  pos = particles[i]->getPosition();
+	  if (this->isContained(pos[0],pos[1],pos[2],finalDomain)) {
                 particles[i]->velocityToParticle(velocityField, scaling);
             }
         }
@@ -757,8 +784,10 @@
     Box3D finalDomain;
     if( intersect(domain, this->getBoundingBox(), finalDomain) )
     {
+      Array<T,3> pos;
         for (pluint i=0; i<particles.size(); ++i) {
-            if (this->isContained(particles[i]->getPosition(),finalDomain)) {
+	  pos = particles[i]->getPosition();
+	  if (this->isContained(pos[0],pos[1],pos[2],finalDomain)) {
                 particles[i]->rhoBarJtoParticle(rhoBarJfield, velIsJ, scaling);
             }
         }
@@ -772,8 +801,10 @@
     Box3D finalDomain;
     if( intersect(domain, this->getBoundingBox(), finalDomain) )
     {
+        Array<T,3> pos;
         for (pluint i=0; i<particles.size(); ++i) {
-            if (this->isContained(particles[i]->getPosition(),finalDomain)) {
+            pos = particles[i]->getPosition();
+            if (this->isContained(pos[0],pos[1],pos[2],finalDomain)) {
                 particles[i]->fluidToParticle(lattice, scaling);
             }
         }
@@ -786,13 +817,16 @@
     Box3D finalDomain;
     if( intersect(domain, this->getBoundingBox(), finalDomain) )
     {
+        Array<T,3> pos; 
         for (pluint i=0; i<particles.size(); ++i) {
             Particle3D<T,Descriptor>* particle = particles[i];
-            if (this->isContained(particle->getPosition(),finalDomain)) {
+            pos = particle->getPosition();
+            if (this->isContained(pos[0],pos[1],pos[2],finalDomain)) {
                 Array<T,3> oldPos( particle->getPosition() );
                 particle->advance();
+                pos = particle->getPosition();
                 if ( (cutOffValue>=T() && normSqr(oldPos-particle->getPosition())<cutOffValue) ||
-                     (!this->isContained(particle->getPosition(),this->getBoundingBox()))  )
+                     (!this->isContained(pos[0],pos[1],pos[2],this->getBoundingBox()))  )
                 {
                     delete particle;
                 }
