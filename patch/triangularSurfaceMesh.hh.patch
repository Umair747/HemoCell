--- triangularSurfaceMesh.hh	2015-01-13 15:05:09.000000000 +0100
+++ triangularSurfaceMesh_new.hh	2016-09-08 16:33:43.000000000 +0200
@@ -286,6 +286,82 @@
 }
 
 template<typename T>
+void TriangularSurfaceMesh<T>::rotateXYZ(T alpha, T beta, T gamma)
+{
+    static const T pi = std::acos((T) -1.0);
+
+    PLB_ASSERT((theta > T() || util::fpequal(theta, T(), eps0)) &&
+               (theta < pi  || util::fpequal(theta, pi, eps0)));
+
+    // Rotation matrix around x axis (column-first)
+    T a[3][3];
+    a[0][0] =  (T) 1.0;
+    a[0][1] =  (T) 0.0;
+    a[0][2] =  (T) 0.0;
+    a[1][0] =  (T) 0.0;
+    a[1][1] =  std::cos(alpha);
+    a[1][2] =  std::sin(alpha);
+    a[2][0] =  (T) 0.0;
+    a[2][1] = -std::sin(alpha);
+    a[2][2] =  std::cos(alpha);
+
+    // Rotation matrix around y axis (column-first)
+    T b[3][3];
+    b[0][0] =  std::cos(beta);
+    b[0][1] =  (T) 0.0;
+    b[0][2] =  -std::sin(beta);
+    b[1][0] =  (T) 0.0;
+    b[1][1] =  (T) 1.0;
+    b[1][2] =  (T) 0.0;
+    b[2][0] =  std::sin(beta);
+    b[2][1] =  (T) 0.0;
+    b[2][2] =  std::cos(beta);
+
+    // Ry * Rx
+    T c[3][3];
+    for (int i = 0; i < 3; i++) {
+        for (int j = 0; j < 3; j++) {
+            c[i][j] = (T) 0.0;
+            for (int k = 0; k < 3; k++) {
+                c[i][j] += a[k][j]*b[i][k];
+            }
+        }
+    }
+
+    // Rotation matrix around z axis (column-first)
+    b[0][0] =  std::cos(gamma);
+    b[0][1] =  std::sin(gamma);
+    b[0][2] =  (T) 0.0;
+    b[1][0] = -std::sin(gamma);
+    b[1][1] =  std::cos(gamma);
+    b[1][2] =  (T) 0.0;
+    b[2][0] =  (T) 0.0;
+    b[2][1] =  (T) 0.0;
+    b[2][2] =  (T) 1.0;
+
+
+    // Rz * [Ry*Rx]
+    for (int i = 0; i < 3; i++) {
+        for (int j = 0; j < 3; j++) {
+            a[i][j] = (T) 0.0;
+            for (int k = 0; k < 3; k++) {
+                a[i][j] += c[k][j]*b[i][k];
+            }
+        }
+    }
+
+    for (plint iVertex = 0; iVertex < numVertices; iVertex++) {
+        Array<T,3> x = getVertex(iVertex);
+        for (int i = 0; i < 3; i++) {
+            getVertex(iVertex)[i] = (T) 0.0;
+            for (int j = 0; j < 3; j++) {
+                getVertex(iVertex)[i] += a[i][j]*x[j];
+            }
+        }
+    }
+}
+
+template<typename T>
 void TriangularSurfaceMesh<T>::smooth(plint maxiter, T relax, bool isMeasureWeighted)
 {
     PLB_ASSERT(maxiter >= 0);
